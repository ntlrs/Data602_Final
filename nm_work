import requests as r
import pandas as pd
import datetime
import json
from time import strftime, gmtime
from pandas.io.json import json_normalize


url = 'https://rest.coinapi.io/v1/quotes/latest?limit=10000'
headers = {'X-CoinAPI-Key' : 'F2F35C56-BE67-4A86-BC00-D5620A306611'}
coin = r.get(url, headers=headers)
data = coin.text
parsed = json.loads(data)
coin_df = pd.DataFrame.from_dict(parsed, orient='columns')

all_exchanges_df = coin_df
all_exchanges_df[['exchange','pair']] = coin_df['symbol_id'].str.split('_', expand=True, n=1)
all_exchanges_list = ['BINANCE', 'POLONIEX', 'BITFINEX']

exchanges2_df = all_exchanges_df[all_exchanges_df.exchange.isin(all_exchanges_list)]

ask_price_df = exchanges2_df[['ask_price', 'exchange', 'pair']]
bid_price_df = exchanges2_df[[ 'bid_price', 'exchange', 'pair']]

ask_price_df = ask_price_df.drop_duplicates(['exchange','pair'])
ask_price_df = ask_price_df.pivot(index='pair', columns='exchange')
ask_price_df = ask_price_df.dropna()
ask_price_df.columns = ask_price_df.columns.droplevel(0)
ask_price_df = ask_price_df.rename_axis(None, axis=1)

bid_price_df = bid_price_df.drop_duplicates(['exchange','pair'])
bid_price_df = bid_price_df.pivot(index='pair', columns='exchange')
bid_price_df = bid_price_df.dropna()
bid_price_df.columns = bid_price_df.columns.droplevel(0)
bid_price_df = bid_price_df.rename_axis(None, axis=1)

spread_df= pd.DataFrame()
spread_df["Binance/Bitfinex"] = bid_price_df.iloc[:,0] - ask_price_df.iloc[:,1]
spread_df["Binance/Poloniex"] = bid_price_df.iloc[:,0] - ask_price_df.iloc[:,2]
spread_df["Bitfinex/Binance"] = bid_price_df.iloc[:,1] - ask_price_df.iloc[:,0]
spread_df["Bitfinex/Poloniex"] = bid_price_df.iloc[:,1] - ask_price_df.iloc[:,2]
spread_df["Poloniex/Binance"] = bid_price_df.iloc[:,2] - ask_price_df.iloc[:,0]
spread_df["Poloniex/Bitfinex"] = bid_price_df.iloc[:,2] - ask_price_df.iloc[:,1]
spread_df = spread_df.reset_index()



spread_df = pd.melt(spread_df, id_vars='pair')
spread_df.columns = ["Pair", "Exchanges", "Arbitrage Value"]

top_10 = spread_df.nlargest(10, 'Arbitrage Value')
top_10 = top_10[(top_10 > 0).all(1)]



def main():    

    menu = ('Get Prices For Available Trading Pairs', 'Predictions', 'Best Chances for Arbitrage', 'Quit')
    while True:
        print("\n")
        print("Arbitrage On Exchanges")
        print("\n")
        print("Find Arbitrage Opportunities for Trading Pairs On Poloniex, Binance, and Bitfinex")
        choice = display_menu(menu,exit_option=5)
        if choice == 1:
           pair = select_crypto()
           exchange = select_exchange()
           ask, bid = get_prices(exchange, pair)
           print("\n")
           print("The Ask Price for " + pair + " is " + str(ask))
           print("The Bid Price for " + pair + " is " + str(bid))
           print("\n")
        elif choice == 2:
            print("\n")
            predexch = get_predexchange()
            crypto1, crypto2 = pred_crypto()
            ML_df = get_prediction(crypto1, crypto2,predexch)
            print(ML_df)
            
        elif choice == 3:
            print("Arbitrage Opportunities")
            print("\n")
            print(top_10)
        elif choice == 4:
            print("bye")
            
        else:
          print("Not An Option ")
          return
      
def display_menu(menu,exit_option=-1):
    ```
    This function controls the main menu
    ```
    for m in menu:
        print(menu.index(m)+1,".  ",m)
    choice = int(input("Enter choice [1-4]: "))
    if choice==exit_option:
        print("Bye")
        quit()
    return choice

def select_crypto():
    ```
    This function returns the currency that we will get the ask & bid price 
    ```
    print("Trading Pairs Available ")
    pair = ["BCH-BTC", "BCH-ETH","DASH-BTC", "ETC-BTC", "ETH-BTC", "LTC-BTC", "OMG-BTC", "OMG-ETH", "XMR-BTC", "XRP-BTC", "ZEC-BTC", "ZRX-BTC","ZRX-ETH"]

    for p in pair:
        print(pair.index(p)+1,".  ", p)
    crypto = int(input("Please Select Pair to View Price: "))
    item = crypto-1
    pair = pair[item]
    pair = pair.lower().replace('-','')
    return pair 

def select_exchange():
    ```
    This function returns the exchange that we will find the ask & bid price 
    ```
    print("Exchanges Available ")
    exchanges = [x.lower() for x in all_exchanges_list]
    for e in exchanges:
        print(exchanges.index(e)+1,".  ", e)
    exchange = int(input("Please Select an exchange: "))
    item = exchange-1
    exchange = exchanges[item] 
    return exchange

def get_prices(exchange, pair):
    ```
    This function gets the ask & bid function from the above functions.
    ```
    querystring = {"symbol":'binance:etcbtc'}
    headers = {'Authorization': 'Token 381c9c2468cd4c67b54b8220a81155db9a1d8ac2'}
    response = r.request("GET", url, headers=headers, params=querystring)
    response = response.text
    parsed = json.loads(response)
    ask = parsed['ask']
    bid = parsed['bid']
    return ask, bid
    
def get_predexchange():
    ```
    This function selects the exchange that we are using to make a prediction
    ```
    exchanges = ['Binance', 'Poloniex', 'Bitfinex']
    for e in exchanges:
        print(exchanges.index(e)+1,".  ", e)
    exchange = int(input("Please Select an Exchange For Prediction: "))
    item = exchange-1
    predexch = exchanges[item] 
    return predexch

def pred_crypto():
    ```
    This function selects the trading pair that we are using to make a prediction
    ```
    pair = ["BCH-BTC", "BCH-ETH","DASH-BTC", "ETC-BTC", "ETH-BTC", "LTC-BTC", "OMG-BTC", "OMG-ETH", "XMR-BTC", "XRP-BTC", "ZEC-BTC", "ZRX-BTC","ZRX-ETH"]
    for p in pair:
        print(pair.index(p)+1,".  ", p)
    crypto = int(input("Please Select Pair to View Prediction: "))
    item = crypto-1
    pair = pair[item]
    crypto1, crypto2 = pair.split('-')
    return crypto1, crypto2 

def get_prediction(crypto1, crypto2,predexch):
    ```
    This function returns the dataframe of information for prediction
    ```
    URL = 'https://min-api.cryptocompare.com/data/histohour?fsym='+crypto1+'&tsym='+crypto2+'&limit=2000&aggregate=1&e='+predexch
    ML = r.get(URL)
    ML = json.loads(ML.text)
    ML_df = json_normalize(ML, record_path = ['Data'],  meta = ['Response','Type','ML','Aggregated'],record_prefix = 'Data_', errors = 'ignore')
    ML_df = pd.DataFrame(ML_df)
    return ML_df

if __name__ == "__main__":
    main()
